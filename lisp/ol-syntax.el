;;; ol-syntax.el --- Org links syntax                      -*- lexical-binding: t; -*-

;; Copyright (C) 2018-2024 Free Software Foundation, Inc.

;; Author: Carsten Dominik <carsten.dominik@gmail.com>

;; This file is part of GNU Emacs.

;; GNU Emacs is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; GNU Emacs is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:

;; This library implements base Org link syntax.

;;; Code:

(require 'org-macs)
(org-assert-version)

(declare-function org-element-update-syntax "org-element" ())
(declare-function org-element-cache-refresh "org-element" (pos))
(declare-function org-element-context "org-element" (&optional element))
(declare-function org-element-org-data "org-element" ())
(declare-function org-element-property "org-element-ast" (property node &optional dflt force-undefer))


;;; Customization

(defgroup org-link nil
  "Options concerning links in Org mode."
  :tag "Org Link"
  :group 'org)

(defcustom org-link-parameters nil
  "Alist of properties that defines all the links in Org mode.

The key in each association is a string of the link type.
Subsequent optional elements make up a property list for that
type.

All properties are optional.  However, the most important ones
are, in this order, `:follow', `:export', and `:store', described
below.

`:follow'

  Function used to follow the link, when the `org-open-at-point'
  command runs on it.  It is called with two arguments: the path,
  as a string, and a universal prefix argument.

  Here, you may use `org-link-open-as-file' helper function for
  types similar to \"file\".

`:export'

  Function that accepts four arguments:
  - the path, as a string,
  - the description as a string, or nil,
  - the export backend,
  - the export communication channel, as a plist.

  When nil, export for that type of link is delegated to the
  backend.

`:store'

  Function responsible for storing the link.  See the function
  `org-store-link-functions' for a description of the expected
  arguments.

Additional properties provide more specific control over the
link.

`:activate-func'

  Function to run at the end of Font Lock activation.  It must
  accept four arguments:
  - the buffer position at the start of the link,
  - the buffer position at its end,
  - the path, as a string,
  - a boolean, non-nil when the link has brackets.

`:complete'

  Function that inserts a link with completion.  The function
  takes one optional prefix argument.

`:insert-description'

  String or function used as a default when prompting users for a
  link's description.  A string is used as-is, a function is
  called with two arguments: the link location (a string such as
  \"~/foobar\", \"id:some-org-id\" or \"https://www.foo.com\")
  and the description generated by `org-insert-link'.  It should
  return the description to use (this reflects the behavior of
  `org-link-make-description-function').  If it returns nil, no
  default description is used, but no error is thrown (from the
  user's perspective, this is equivalent to a default description
  of \"\").

`:display'

  Value for `invisible' text property on the hidden parts of the
  link.  The most useful value is `full', which will not fold the
  link in descriptive display.  Default is `org-link'.

`:face'

  Face for the link, or a function returning a face.  The
  function takes one argument, which is the path.

  The default face is `org-link'.

`:help-echo'

  String or function used as a value for the `help-echo' text
  property.  The function is called with one argument, the help
  string to display, and should return a string.

`:htmlize-link'

  Function or plist for the `htmlize-link' text property.  The
  function takes no argument.

  Default is (:uri \"type:path\")

`:keymap'

  Active keymap when point is on the link.  Default is
  `org-mouse-map'.

`:mouse-face'

  Face used when hovering over the link.  Default is
  `highlight'."
  :group 'org-link
  :package-version '(Org . "9.1")
  :type '(alist :tag "Link display parameters"
		:value-type plist))

(defcustom org-link-abbrev-alist nil
  "Alist of link abbreviations.
The car of each element is a string, to be replaced at the start of a link.
The cdrs are replacement values, like (\"linkkey\" . REPLACE).  Abbreviated
links in Org buffers can have an optional tag after a double colon, e.g.,

     [[linkkey:tag][description]]

The `linkkey' must be a single word, starting with a letter, followed
by letters, numbers, `-' or `_'.

If REPLACE is a string, the tag will simply be appended to create the link.
If the string contains \"%s\", the tag will be inserted there.  If the string
contains \"%h\", it will cause a url-encoded version of the tag to be inserted
at that point (see the function `url-hexify-string').  If the string contains
the specifier \"%(my-function)\", then the custom function `my-function' will
be invoked: this function takes the tag as its only argument and must return
a string.

REPLACE may also be a function that will be called with the tag as the
only argument to create the link, which should be returned as a string.

See the manual for examples."
  :group 'org-link
  :type '(repeat
	  (cons (string :tag "Protocol")
		(choice
		 (string :tag "Format")
		 (function))))
  :safe (lambda (alist)
          (when (listp alist)
            (catch :unsafe
              (dolist (val alist)
	        (pcase val
	          (`(,(pred stringp) . ,(pred stringp)) t)
	          (_ (throw :unsafe nil))))
              t))))

(defcustom org-link-translation-function nil
  "Function to translate links with different syntax to Org syntax.
This can be used to translate links created for example by the Planner
or emacs-wiki packages to Org syntax.
The function must accept two parameters, a TYPE containing the link
protocol name like \"rmail\" or \"gnus\" as a string, and the linked path,
which is everything after the link protocol.  It should return a cons
with possibly modified values of type and path."
  :group 'org-link-follow
  :type '(choice (const nil) (function))
  :safe #'null)

;;; Public variables

(defconst org-target-regexp (let ((border "[^<>\n\r \t]"))
			      (format "<<\\(%s\\|%s[^<>\n\r]*%s\\)>>"
				      border border border))
  "Regular expression matching a link target.")

(defconst org-radio-target-regexp (format "<%s>" org-target-regexp)
  "Regular expression matching a radio target.")

(defvar-local org-target-link-regexp nil
  "Regular expression matching radio targets in plain text.")

(defconst org-target-link-regexp-limit (ash 2 12)
  "Maximum allowed length of regexp.
The number should generally be ~order of magnitude smaller than
MAX_BUF_SIZE in src/regex-emacs.c.  The number of regexp-emacs.c is
for processed regexp, which appears to be larger compared to the
original string length.")

(defvar-local org-target-link-regexps nil
  "List of regular expressions matching radio targets in plain text.
This list is non-nil, when a single regexp would be too long to match
all the possible targets, exceeding Emacs's regexp length limit.")

(defvar org-link-types-re nil
  "Matches a link that has a url-like prefix like \"http:\".")

(defvar org-link-angle-re nil
  "Matches link with angular brackets, spaces are allowed.")

(defvar org-link-plain-re nil
  "Matches plain link, without spaces.
Group 1 must contain the link type (i.e. https).
Group 2 must contain the link path (i.e. //example.com).
Used by `org-element-link-parser'.")

(defvar org-link-bracket-re nil
  "Matches a link in double brackets.")

(defvar org-link-any-re nil
  "Regular expression matching any link.")

(defvar-local org-link-abbrev-alist-local nil
  "Buffer-local version of `org-link-abbrev-alist', which see.
The value of this is taken from the LINK keywords.")


;;; Public API

(defun org-link-types ()
  "Return a list of known link types."
  (mapcar #'car org-link-parameters))

(defun org-link-get-parameter (type key)
  "Get TYPE link property for KEY.
TYPE is a string and KEY is a plist keyword.  See
`org-link-parameters' for supported keywords."
  (plist-get (cdr (assoc type org-link-parameters))
	     key))

(defun org-link-set-parameters (type &rest parameters)
  "Set link TYPE properties to PARAMETERS.
PARAMETERS should be keyword value pairs.  See
`org-link-parameters' for supported keys."
  (when (member type '("coderef" "custom-id" "fuzzy" "radio"))
    (error "Cannot override reserved link type: %S" type))
  (let ((data (assoc type org-link-parameters)))
    (if data (setcdr data (org-combine-plists (cdr data) parameters))
      (push (cons type parameters) org-link-parameters)
      (org-link-make-regexps)
      (when (featurep 'org-element) (org-element-update-syntax)))))

;; This way, one can add multiple functions as, say, :follow parameter.
;; For example,
;; (add-function :before-until (org-link-get-parameter "id" :follow) #'my-function)
;; See https://orgmode.org/list/a123389c-8f86-4836-a4fe-1e3f4281d33b@app.fastmail.com
(gv-define-setter org-link-get-parameter (value type key)
  `(org-link-set-parameters ,type ,key ,value))

(defun org-link-expand-abbrev (link)
  "Replace link abbreviations in LINK string.
Abbreviations are defined in `org-link-abbrev-alist'."
  (if (not (string-match "^\\([^:]*\\)\\(::?\\(.*\\)\\)?$" link)) link
    (let* ((key (match-string 1 link))
	   (tag (and (match-end 2) (match-string 3 link)))
           (as (or (assoc key (org-element-property :link-abbrevs (org-element-org-data)))
		   (assoc key org-link-abbrev-alist)))
	   rpl)
      (if (not as)
	  link
	(setq rpl (cdr as))
        (cl-macrolet
            ((eval-or-disable (&rest body)
               "Run BODY and disable AS abbrev if it errs."
               `(condition-case err
	            (progn ,@body)
                  (error
                   (org-display-warning
                    (format "Disabling link abbrev %s <- %s after expansion failure: %S"
                            rpl link (error-message-string err)))
                   (setq org-link-abbrev-alist-local (delete as org-link-abbrev-alist-local)
	                 org-link-abbrev-alist (delete as org-link-abbrev-alist))
                   link))))
          ;; Drop any potentially dangerous text properties like
          ;; `modification-hooks' that may be used as an attack vector.
          (substring-no-properties
           (cond
            ((symbolp rpl)
             (eval-or-disable
              (let ((expanded (funcall rpl tag)))
                (unless (stringp expanded)
                  (error "%s did not return a string: %S" rpl expanded))
                expanded)))
            ((string-match "%(\\([^)]+\\))" rpl)
             (let ((rpl-fun-symbol (intern-soft (match-string 1 rpl))))
               ;; Using `unsafep-function' is not quite enough because
               ;; Emacs considers functions like `genenv' safe, while
               ;; they can potentially be used to expose private system
               ;; data to attacker if abbreviated link is clicked.
               (if (or (eq t (get rpl-fun-symbol 'org-link-abbrev-safe))
                       (eq t (get rpl-fun-symbol 'pure)))
                   (eval-or-disable
                    (replace-match
                     (save-match-data
                       (funcall rpl-fun-symbol tag))
                     t t rpl))
                 (org-display-warning
                  (format "Disabling unsafe link abbrev: %s
You may mark function safe via (put '%s 'org-link-abbrev-safe t)"
                          rpl (match-string 1 rpl)))
                 (setq org-link-abbrev-alist-local (delete as org-link-abbrev-alist-local)
                       org-link-abbrev-alist (delete as org-link-abbrev-alist))
                 link
                 )))
            ((string-match "%s" rpl) (replace-match (or tag "") t t rpl))
            ((string-match "%h" rpl)
             (replace-match (url-hexify-string (or tag "")) t t rpl))
            (t (concat rpl tag)))))))))

(defun org-link-make-regexps ()
  "Update the link regular expressions.
This should be called after the variable `org-link-parameters' has changed."
  (let ((types-re (regexp-opt (org-link-types) t)))
    (setq org-link-types-re
	  (concat "\\`" types-re ":")
	  org-link-angle-re
	  (format "<%s:\\([^>\n]*\\(?:\n[ \t]*[^> \t\n][^>\n]*\\)*\\)>"
		  types-re)
	  org-link-plain-re
          (let* ((non-space-bracket "[^][ \t\n()<>]")
	         (parenthesis
		  `(seq (any "<([")
		        (0+ (or (regex ,non-space-bracket)
			        (seq (any "<([")
				     (0+ (regex ,non-space-bracket))
				     (any "])>"))))
		        (any "])>"))))
	    ;; Heuristics for an URL link inspired by
	    ;; https://daringfireball.net/2010/07/improved_regex_for_matching_urls
	    (rx-to-string
	     `(seq word-start
                   ;; Link type: match group 1.
		   (regexp ,types-re)
		   ":"
                   ;; Link path: match group 2.
                   (group
		    (1+ (or (regex ,non-space-bracket)
			    ,parenthesis))
		    (or (regexp "[^[:punct:][:space:]\n]")
                        ;; Allow "-" punctuation, as an exception
                        ;; See https://list.orgmode.org/orgmode/87sexh9ddv.fsf@ice9.digital/
                        ;; This is also in line with the heuristics
                        ;; above - it also does not include "-"
                        ;; punctuation.
                        ?-
		        ?/
		        ,parenthesis)))))
          org-link-bracket-re
          (rx (seq "[["
	           ;; URI part: match group 1.
	           (group
	            (one-or-more
                     (or (not (any "[]\\"))
			 (and "\\" (zero-or-more "\\\\") (any "[]"))
			 (and (one-or-more "\\") (not (any "[]"))))))
		   "]"
		   ;; Description (optional): match group 2.
		   (opt "[" (group (+? anything)) "]")
		   "]"))
	  org-link-any-re
	  (concat "\\(" org-link-bracket-re "\\)\\|\\("
		  org-link-angle-re "\\)\\|\\("
		  org-link-plain-re "\\)"))))

(defun org-link-escape (link)
  "Backslash-escape sensitive characters in string LINK."
  (replace-regexp-in-string
   (rx (seq (group (zero-or-more "\\")) (group (or string-end (any "[]")))))
   (lambda (m)
     (concat (match-string 1 m)
	     (match-string 1 m)
	     (and (/= (match-beginning 2) (match-end 2)) "\\")))
   link nil t 1))

(defun org-link-unescape (link)
  "Remove escaping backslash characters from string LINK."
  (replace-regexp-in-string
   (rx (group (one-or-more "\\")) (or string-end (any "[]")))
   (lambda (_)
     (concat (make-string (/ (- (match-end 1) (match-beginning 1)) 2) ?\\)))
   link nil t 1))

;;;###autoload
(defun org-update-radio-target-regexp ()
  "Find all radio targets in this file and update the regular expression."
  (interactive)
  (let ((old-regexp org-target-link-regexp)
	;; Some languages, e.g., Chinese, do not use spaces to
        ;; separate words.  Also allow surrounding radio targets with
	;; line-breakable characters.
	(before-re "\\(?:^\\|[^[:alnum:]]\\|\\c|\\)\\(")
	(after-re "\\)\\(?:$\\|[^[:alnum:]]\\|\\c|\\)")
	(targets
	 (org-with-wide-buffer
	  (goto-char (point-min))
	  (let (rtn)
	    (while (re-search-forward org-radio-target-regexp nil t)
	      ;; Make sure point is really within the object.
	      (backward-char)
	      (let ((obj (org-element-context)))
		(when (org-element-type-p obj 'radio-target)
		  (cl-pushnew (org-element-property :value obj) rtn
			      :test #'equal))))
	    rtn))))
    (setq targets
          (sort targets
                (lambda (a b)
                  (> (length a) (length b)))))
    (setq org-target-link-regexp
	  (and targets
	       (concat before-re
		       (mapconcat
			(lambda (x)
			  (replace-regexp-in-string
			   " +" "\\s-+" (regexp-quote x) t t))
			targets
			"\\|")
		       after-re)))
    (setq org-target-link-regexps nil)
    (let (current-length sub-targets)
      (when (<= org-target-link-regexp-limit (length org-target-link-regexp))
        (while (or targets sub-targets)
          (when (and sub-targets
                     (or (not targets)
                         (>= (+ current-length (length (car targets)))
                            org-target-link-regexp-limit)))
            (push (concat before-re
                          (mapconcat
			   (lambda (x)
			     (replace-regexp-in-string
			      " +" "\\s-+" (regexp-quote x) t t))
			   (nreverse sub-targets)
			   "\\|")
		          after-re)
                  org-target-link-regexps)
            (setq current-length nil
                  sub-targets nil))
          (unless current-length
            (setq current-length (+ (length before-re) (length after-re))))
          (when targets (push (pop targets) sub-targets))
          (cl-incf current-length (length (car sub-targets))))
        (setq org-target-link-regexps (nreverse org-target-link-regexps))))
    (unless (equal old-regexp org-target-link-regexp)
      ;; Clean-up cache.
      (let ((regexp (cond ((not old-regexp) org-target-link-regexp)
			  ((not org-target-link-regexp) old-regexp)
			  (t
			   (concat before-re
				   (mapconcat
				    (lambda (re)
				      (substring re (length before-re)
						 (- (length after-re))))
				    (list old-regexp org-target-link-regexp)
				    "\\|")
				   after-re)))))
	(when (and (featurep 'org-element)
                   (not (bound-and-true-p org-mode-loading)))
          (if org-target-link-regexps
              (org-element-cache-reset)
	    (org-with-point-at 1
	      (while (re-search-forward regexp nil t)
	        (org-element-cache-refresh (match-beginning 1)))))))
      ;; Re fontify buffer.
      (when (memq 'radio org-highlight-links)
	(org-restart-font-lock)))))

(provide 'ol-syntax)

;; Local variables:
;; generated-autoload-file: "org-loaddefs.el"
;; End:

;;; ol-syntax.el ends here
