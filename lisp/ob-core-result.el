;;; ob-core-result.el --- Babel results of evaluation          -*- lexical-binding: t; -*-

;; Copyright (C) 2009-2024 Free Software Foundation, Inc.

;; Authors: Eric Schulte
;;	Dan Davison
;; Keywords: literate programming, reproducible research
;; URL: https://orgmode.org

;; This file is part of GNU Emacs.

;; GNU Emacs is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; GNU Emacs is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:

;; This library implements Org babel API to insert and query results
;; of evaluation.

;;; Code:

(require 'org-macs)
(org-assert-version)

(require 'ol)
(require 'org-indent-static)

(defcustom org-babel-results-keyword "RESULTS"
  "Keyword used to name results generated by code blocks.
It should be \"RESULTS\".  However any capitalization may be
used."
  :group 'org-babel
  :version "24.4"
  :package-version '(Org . "8.0")
  :type 'string
  :safe (lambda (v)
	  (and (stringp v)
	       (org-string-equal-ignore-case "RESULTS" v))))

(defcustom org-babel-hash-show-time nil
  "Non-nil means show the time the code block was evaluated in the result hash."
  :group 'org-babel
  :type 'boolean
  :package-version '(Org . "9.0")
  :safe #'booleanp)

(defcustom org-babel-uppercase-example-markers nil
  "When non-nil, begin/end example markers will be inserted in upper case."
  :group 'org-babel
  :type 'boolean
  :version "26.1"
  :package-version '(Org . "9.1")
  :safe #'booleanp)

(defcustom org-babel-inline-result-wrap "=%s="
  "Format string used to wrap inline results.
This string must include a \"%s\" which will be replaced by the results."
  :group 'org-babel
  :type 'string)
(put 'org-babel-inline-result-wrap
     'safe-local-variable
     (lambda (value)
       (and (stringp value)
	    (string-match-p "%s" value))))

(defconst org-babel-result-regexp
  (rx (seq bol
           (zero-or-more (any "\t "))
           "#+results"
           (opt "["
		;; Time stamp part.
		(opt "("
                     (= 4 digit) (= 2 "-" (= 2 digit))
                     " "
                     (= 2 digit) (= 2 ":" (= 2 digit))
                     ") ")
		;; SHA1 hash.
		(group (one-or-more hex-digit))
		"]")
           ":"
           (zero-or-more (any "\t "))))
  "Regular expression used to match result lines.
If the results are associated with a hash key then the hash will
be saved in match group 1.")

(defvar org-babel-hash-show 4
  "Number of initial characters to show of a hidden results hash.")

(defvar org-babel-min-lines-for-block-output 10
  "The minimum number of lines for block output.
If number of lines of output is equal to or exceeds this
value, the output is placed in a #+begin_example...#+end_example
block.  Otherwise the output is marked as literal by inserting
colons at the starts of the lines.  This variable only takes
effect if the :results output option is in effect.")

(defconst org-babel-result-w-name-regexp
  (concat org-babel-result-regexp "\\(?9:[^ \t\n\r\v\f]+\\)")
  "Regexp matching a RESULTS keyword with a name.
Name is saved in match group 9.")

;;; Insert result

(defun org-babel--file-desc (params result)
  "Retrieve description for file link result of evaluation.
PARAMS is header argument values.  RESULT is the file link as returned
by the code block.

When `:file-desc' header argument is provided use its value or
duplicate RESULT in the description.

When `:file-desc' is missing, return nil."
  (pcase (assq :file-desc params)
    (`nil nil)
    (`(:file-desc) result)
    (`(:file-desc . ,(and (pred stringp) val)) val)))

(declare-function org-table-align "org-table-align" ())
(declare-function org-table-end "org-table-core" (&optional table-type))
(declare-function orgtbl-to-orgtbl "org-table-export" (table params))
(declare-function org-escape-code-in-region "org-src" (beg end))
(declare-function org-list-to-org "org-list" (list &optional params))
(defun org-babel-insert-result (result &optional result-params info hash lang exec-time)
  "Insert RESULT into the current buffer.

By default RESULT is inserted after the end of the current source
block.  The RESULT of an inline source block usually will be
wrapped inside a `results' macro and placed on the same line as
the inline source block.  The macro is stripped upon export.
Multiline and non-scalar RESULTS from inline source blocks are
not allowed.  When EXEC-TIME is provided it may be included in a
generated message.  With optional argument RESULT-PARAMS controls
insertion of results in the Org mode file.  RESULT-PARAMS is a list
that can contain the following values:

replace - (default option) insert results after the source block
          or inline source block replacing any previously
          inserted results.

silent -- no results are inserted into the Org buffer but
          the results are echoed to the minibuffer and are
          ingested by Emacs (a potentially time consuming
          process).

none ---- no results are inserted into the Org buffer nor
          echoed to the minibuffer.  They are not processed into
          Emacs-lisp objects at all.

file ---- the results are interpreted as a file path, and are
          inserted into the buffer using the Org file syntax.

list ---- the results are interpreted as an Org list.

raw ----- results are added directly to the Org file.  This is
          a good option if you code block will output Org
          formatted text.

drawer -- results are added directly to the Org file as with
          \"raw\", but are wrapped in a RESULTS drawer or results
          macro, allowing them to later be replaced or removed
          automatically.

org ----- results are added inside of a \"src_org{}\" or \"#+BEGIN_SRC
          org\" block depending on whether the current source block is
          inline or not.  They are not comma-escaped when inserted,
          but Org syntax here will be discarded when exporting the
          file.

html ---- results are added inside of a #+BEGIN_EXPORT HTML block
          or html export snippet depending on whether the current
          source block is inline or not.  This is a good option
          if your code block will output html formatted text.

latex --- results are added inside of a #+BEGIN_EXPORT LATEX
          block or latex export snippet depending on whether the
          current source block is inline or not.  This is a good
          option if your code block will output latex formatted
          text.

code ---- the results are extracted in the syntax of the source
          code of the language being evaluated and are added
          inside of a source block with the source-code language
          set appropriately.  Also, source block inlining is
          preserved in this case.  Note this relies on the
          optional LANG argument.

list ---- the results are rendered as a list.  This option not
          allowed for inline source blocks.

table --- the results are rendered as a table.  This option not
          allowed for inline source blocks.

INFO is the src block info, as returned by
`org-babel-get-src-block-info' (which see).  Some values from its
PARAMETERS part (header argument alist) can affect the inserted
result:

:file-desc - when RESULT-PARAMS contains \"file\", use it as
             description of the inserted link.

:wrap        the effect is similar to `latex' in RESULT-PARAMS but
             using the argument supplied to specify the export block
             or snippet type."
  (cond ((stringp result)
	 (setq result (substring-no-properties result))
	 (when (member "file" result-params)
	   (setq result
                 (org-babel-result-to-file
		  result
		  (org-babel--file-desc (nth 2 info) result)
                  'attachment))))
	((listp result))
	(t (setq result (format "%S" result))))

  (if (and result-params (member "silent" result-params))
      (progn (message (replace-regexp-in-string "%" "%%" (format "%S" result)))
	     result)
    (let ((inline (let ((context (org-element-context)))
		    (and (org-element-type-p
                          context '(inline-babel-call inline-src-block))
			 context))))
      (when inline
	(let ((warning
	       (or (and (member "table" result-params) "`:results table'")
                   (and (member "drawer" result-params) "`:results drawer'")
		   (and result (listp result) "list result")
		   (and result (string-match-p "\n." result) "multiline result")
		   (and (member "list" result-params) "`:results list'"))))
	  (when warning
	    (user-error "Inline error: %s cannot be used" warning))))
      (save-excursion
	(let* ((visible-beg (point-min-marker))
	       (visible-end (copy-marker (point-max) t))
	       (existing-result (org-babel-where-is-src-block-result t nil hash))
	       (results-switches (cdr (assq :results_switches (nth 2 info))))
	       ;; When results exist outside of the current visible
	       ;; region of the buffer, be sure to widen buffer to
	       ;; update them.
	       (outside-scope (and existing-result
				   (buffer-narrowed-p)
				   (or (> visible-beg existing-result)
				       (<= visible-end existing-result))))
	       beg end indent)
	  ;; Ensure non-inline results end in a newline.
	  (when (and (org-string-nw-p result)
		     (not inline)
		     (not (string-equal (substring result -1) "\n")))
	    (setq result (concat result "\n")))
	  (unwind-protect
	      (progn
		(when outside-scope (widen))
		(if existing-result (goto-char existing-result)
		  (goto-char (org-element-end inline))
		  (skip-chars-backward " \t"))
		(unless inline
		  (setq indent (current-indentation))
		  (forward-line 1))
		(setq beg (point))
		(cond
		 (inline
		   ;; Make sure new results are separated from the
		   ;; source code by one space.
		   (unless existing-result
		     (insert " ")
		     (setq beg (point))))
		 ((member "replace" result-params)
		  (delete-region (point) (org-babel-result-end)))
		 ((member "append" result-params)
		  (goto-char (org-babel-result-end)) (setq beg (point-marker)))
		 ;; ((member "prepend" result-params)) ; already there
                 )
		(setq results-switches
		      (if results-switches (concat " " results-switches) ""))
		(let ((wrap
		       (lambda (start finish &optional no-escape no-newlines
				 inline-start inline-finish)
			 (when inline
			   (setq start inline-start)
			   (setq finish inline-finish)
			   (setq no-newlines t))
			 (let ((before-finish (copy-marker end)))
			   (goto-char end)
			   (insert (concat finish (unless no-newlines "\n")))
			   (goto-char beg)
			   (insert (concat start (unless no-newlines "\n")))
			   (unless no-escape
                             (require 'org-src)
			     (org-escape-code-in-region
			      (min (point) before-finish) before-finish))
			   (goto-char end))))
		      (tabulablep
		       (lambda (r)
			 ;; Non-nil when result R can be turned into
			 ;; a table.
                         (and (proper-list-p r)
			      (cl-every
                               (lambda (e) (or (atom e) (proper-list-p e)))
			       result)))))
		  ;; insert results based on type
		  (cond
		   ;; Do nothing for an empty result.
		   ((null result))
		   ;; Insert a list if preferred.
		   ((member "list" result-params)
                    (require 'org-list)
		    (insert
		     (org-trim
		      (org-list-to-org
                       ;; We arbitrarily choose to format non-strings
                       ;; as %S.
		       (cons 'unordered
			     (mapcar
			      (lambda (e)
                                (cond
                                 ((stringp e) (list e))
                                 ((listp e)
                                  (mapcar
                                   (lambda (x)
                                     (if (stringp x) x (format "%S" x)))
                                   e))
                                 (t (list (format "%S" e)))))
			      (if (listp result) result
				(split-string result "\n" t))))
		       '(:splicep nil :istart "- " :iend "\n")))
		     "\n"))
		   ;; Try hard to print RESULT as a table.  Give up if
		   ;; it contains an improper list.
		   ((funcall tabulablep result)
                    (require 'org-table-align)
                    (require 'org-table-core)
                    (require 'org-table-export)
		    (goto-char beg)
		    (insert (concat (orgtbl-to-orgtbl
				     (if (cl-every
					  (lambda (e)
					    (or (eq e 'hline) (listp e)))
					  result)
					 result
				       (list result))
				     nil)
				    "\n"))
		    (goto-char beg)
		    (when (org-at-table-p) (org-table-align))
		    (goto-char (org-table-end)))
		   ;; Print verbatim a list that cannot be turned into
		   ;; a table.
		   ((listp result) (insert (format "%s\n" result)))
		   ((member "file" result-params)
		    (when inline
		      (setq result (org-macro-escape-arguments result)))
		    (insert result))
		   ((and inline (not (member "raw" result-params)))
		    (insert (org-macro-escape-arguments
			     (org-babel-chomp result "\n"))))
		   (t (goto-char beg) (insert result)))
		  (setq end (copy-marker (point) t))
		  ;; Possibly wrap result.
		  (cond
		   ((assq :wrap (nth 2 info))
		    (let* ((full (or (cdr (assq :wrap (nth 2 info))) "results"))
			   (split (split-string full))
			   (type (car split))
			   (opening-line (concat "#+begin_" full))
			   (closing-line (concat "#+end_" type)))
		      (cond
		       ;; Escape contents from "export" wrap.  Wrap
		       ;; inline results within an export snippet with
		       ;; appropriate value.
		       ((org-string-equal-ignore-case type "export")
			(let ((backend (pcase split
					 (`(,_) "none")
					 (`(,_ ,b . ,_) b))))
			  (funcall wrap
				   opening-line closing-line
				   nil nil
				   (format "{{{results(@@%s:"
					   backend) "@@)}}}")))
		       ;; Escape contents from "example" wrap.  Mark
		       ;; inline results as verbatim.
		       ((org-string-equal-ignore-case type "example")
			(funcall wrap
				 opening-line closing-line
				 nil nil
				 "{{{results(=" "=)}}}"))
		       ;; Escape contents from "src" wrap.  Mark
		       ;; inline results as inline source code.
		       ((org-string-equal-ignore-case type "src")
			(let ((inline-open
			       (pcase split
				 (`(,_)
				  "{{{results(src_none{")
				 (`(,_ ,language)
				  (format "{{{results(src_%s{" language))
				 (`(,_ ,language . ,rest)
				  (let ((r (mapconcat #'identity rest " ")))
				    (format "{{{results(src_%s[%s]{"
					    language r))))))
			  (funcall wrap
				   opening-line closing-line
				   nil nil
				   inline-open "})}}}")))
		       ;; Do not escape contents in non-verbatim
		       ;; blocks.  Return plain inline results.
		       (t
			(funcall wrap
				 opening-line closing-line
				 t nil
				 "{{{results(" ")}}}")))))
		   ((member "html" result-params)
		    (funcall wrap "#+begin_export html" "#+end_export" nil nil
			     "{{{results(@@html:" "@@)}}}"))
		   ((member "latex" result-params)
		    (funcall wrap "#+begin_export latex" "#+end_export" nil nil
			     "{{{results(@@latex:" "@@)}}}"))
		   ((member "org" result-params)
		    (goto-char beg) (when (org-at-table-p) (org-cycle))
		    (funcall wrap "#+begin_src org" "#+end_src" nil nil
			     "{{{results(src_org{" "})}}}"))
		   ((member "code" result-params)
		    (let ((lang (or lang "none")))
		      (funcall wrap (format "#+begin_src %s%s" lang results-switches)
			       "#+end_src" nil nil
			       (format "{{{results(src_%s[%s]{" lang results-switches)
			       "})}}}")))
		   ((member "raw" result-params)
		    (goto-char beg) (when (org-at-table-p) (org-cycle)))
		   ((or (member "drawer" result-params)
			;; Stay backward compatible with <7.9.2
			(member "wrap" result-params))
		    (goto-char beg) (when (org-at-table-p) (org-cycle))
		    (funcall wrap ":results:" ":end:" 'no-escape nil
			     "{{{results(" ")}}}"))
		   ((and inline (member "file" result-params))
		    (funcall wrap nil nil nil nil "{{{results(" ")}}}"))
		   ((and (not (funcall tabulablep result))
			 (not (member "file" result-params)))
		    (let ((org-babel-inline-result-wrap
			   ;; Hard code {{{results(...)}}} on top of
			   ;; customization.
			   (format "{{{results(%s)}}}"
				   org-babel-inline-result-wrap)))
		      (org-babel-examplify-region
		       beg end results-switches inline)))))
		;; Possibly indent results in par with #+results line.
		(when (and (not inline) (numberp indent) (> indent 0)
			   ;; In this case `table-align' does the work
			   ;; for us.
			   (not (and (listp result)
				   (member "append" result-params))))
		  (indent-rigidly beg end indent))
                (unless noninteractive
                  (let ((time-info
                         ;; Only show the time when something other than
                         ;; 0s will be shown, i.e. check if the time is at
                         ;; least half of the displayed precision.
                         (if (and exec-time (> (float-time exec-time) 0.05))
                             (format " (took %.1fs)" (float-time exec-time))
                           "")))
                    (if (null result)
                        (if (member "value" result-params)
                            (message "Code block returned no value%s." time-info)
                          (message "Code block produced no output%s." time-info))
                      (message "Code block evaluation complete%s." time-info)))))
	    (when end (set-marker end nil))
	    (when outside-scope (narrow-to-region visible-beg visible-end))
	    (set-marker visible-beg nil)
	    (set-marker visible-end nil)))))))

(declare-function orgtbl-to-generic "org-table-export" (table params))
(defun org-babel-format-result (result &optional sep)
  "Format RESULT for writing to file.
When RESULT is a list, write it as a table, use tab or SEP as column
separator."
  (let ((echo-res (lambda (r) (if (stringp r) r (format "%S" r)))))
    (if (listp result)
	;; table result
        (progn
          (require 'org-table-export)
          (orgtbl-to-generic
           result (list :sep (or sep "\t") :fmt echo-res)))
      ;; scalar result
      (funcall echo-res result))))

(declare-function org-attach-dir "org-attach"
                  (&optional create-if-not-exists-p no-fs-check))
(defun org-babel-result-to-file (result &optional description type)
  "Convert RESULT into an Org link with optional DESCRIPTION.
If the `default-directory' is different from the containing
file's directory then expand relative links.

If the optional TYPE is passed as `attachment' and the path is a
descendant of the DEFAULT-DIRECTORY, the generated link will be
specified as an \"attachment:\" style link."
  (when (stringp result)
    (let* ((result-file-name (expand-file-name result))
           (base-file-name (buffer-file-name (buffer-base-buffer)))
           (base-directory (and base-file-name
                                (file-name-directory base-file-name)))
           (same-directory?
	    (and base-file-name
	         (not (string= (expand-file-name default-directory)
			     (expand-file-name
			      base-directory)))))
           (request-attachment (eq type 'attachment))
           (attach-dir (when request-attachment
                         (require 'org-attach)
                         (let* ((default-directory base-directory)
                                (dir (org-attach-dir nil t)))
                           (when dir
                             (expand-file-name dir)))))
           (in-attach-dir (and request-attachment
                               attach-dir
                               (string-prefix-p
                                attach-dir
                                result-file-name))))
      (format "[[%s:%s]%s]"
              (pcase type
                ((and 'attachment (guard in-attach-dir)) "attachment")
                (_ "file"))
              (if (and request-attachment in-attach-dir)
                  (file-relative-name
                   result-file-name
                   (file-name-as-directory attach-dir))
	        (if (and default-directory
		         base-file-name same-directory?)
		    (if (eq org-link-file-path-type 'adaptive)
		        (file-relative-name
		         result-file-name
                         (file-name-directory
			  base-file-name))
		      result-file-name)
		  result))
	      (if description (concat "[" description "]") "")))))

(defun org-babel--clear-results-maybe (hash)
  "Clear results when hash doesn't match HASH.

When results hash does not match HASH, remove RESULTS keyword at
point, along with related contents.  Do nothing if HASH is nil.

Return a non-nil value if results were cleared.  In this case,
leave point where new results should be inserted."
  (when hash
    (let ((case-fold-search t)) (looking-at org-babel-result-regexp))
    (unless (string= (match-string 1) hash)
      (let* ((e (org-element-at-point))
	     (post (copy-marker (org-element-post-affiliated e))))
	;; Delete contents.
	(delete-region post
		       (save-excursion
			 (goto-char (org-element-end e))
			 (skip-chars-backward " \t\n")
			 (line-beginning-position 2)))
	;; Delete RESULT keyword.  However, if RESULTS keyword is
	;; orphaned, ignore this part.  The deletion above already
	;; took care of it.
	(unless (= (point) post)
	  (delete-region (line-beginning-position)
			 (line-beginning-position 2)))
	(goto-char post)
	(set-marker post nil)
	t))))

(defun org-babel--insert-results-keyword (name hash)
  "Insert RESULTS keyword with NAME value at point.
If NAME is nil, results are anonymous.  HASH is a string used as
the results hash, or nil.  Leave point before the keyword."
  (save-excursion (insert "\n"))	;open line to indent.
  (org-indent-line)
  (delete-char 1)
  (insert (concat "#+" org-babel-results-keyword
		  (cond ((not hash) nil)
			(org-babel-hash-show-time
			 (format "[%s %s]"
				 (format-time-string "(%F %T)")
				 hash))
			(t (format "[%s]" hash)))
		  ":"
		  (when name (concat " " name))
		  "\n"))
  ;; Make sure results are going to be followed by at least one blank
  ;; line so they do not get merged with the next element, e.g.,
  ;;
  ;;   #+results:
  ;;   : 1
  ;;
  ;;   : fixed-width area, unrelated to the above.
  (unless (looking-at "^[ \t]*$") (save-excursion (insert "\n")))
  (forward-line -1)
  (when hash (org-babel-hide-hash)))

(defun org-babel-examplify-region (beg end &optional results-switches inline)
  "Comment out region BEG..END using the inline `==' or `: ' org example quote.
When INLINE is non-nil, use the inline verbatim markup.
When INLINE is nil and RESULTS-SWITCHES is non-nil, RESULTS-SWITCHES is
used as a string to be appended to #+begin_example line."
  (interactive "*r")
  (let ((maybe-cap
	 (lambda (str)
	   (if org-babel-uppercase-example-markers (upcase str) str))))
    (if inline
	(save-excursion
	  (goto-char beg)
	  (insert (format org-babel-inline-result-wrap
			  (delete-and-extract-region beg end))))
      (let ((size (count-lines beg end)))
	(save-excursion
	  (cond ((= size 0))	      ; do nothing for an empty result
		((< size org-babel-min-lines-for-block-output)
		 (goto-char beg)
		 (dotimes (_ size)
		   (forward-line 0) (insert ": ") (forward-line 1)))
		(t
		 (goto-char beg)
		 (insert (if results-switches
			     (format "%s%s\n"
				     (funcall maybe-cap "#+begin_example")
				     results-switches)
			   (funcall maybe-cap "#+begin_example\n")))
		 (let ((p (point)))
		   (if (markerp end) (goto-char end) (forward-char (- end beg)))
		   (org-escape-code-in-region p (point)))
		 (insert (funcall maybe-cap "#+end_example\n")))))))))

;;; Remove result

(defun org-babel-remove-result (&optional info keep-keyword)
  "Remove the result of the current source block.
INFO argument is currently ignored.
When KEEP-KEYWORD is non-nil, keep the #+RESULT keyword and just remove
the rest of the result."
  (interactive)
  (let ((location (org-babel-where-is-src-block-result nil info))
	(case-fold-search t))
    (when location
      (save-excursion
        (goto-char location)
	(when (looking-at org-babel-result-regexp)
	  (delete-region
	   (if keep-keyword (line-beginning-position 2)
	     (save-excursion
	       (skip-chars-backward " \r\t\n")
	       (line-beginning-position 2)))
	   (progn (forward-line) (org-babel-result-end))))))))

(defun org-babel-remove-inline-result (&optional datum)
  "Remove the result of DATUM or the current inline-src-block or babel call.
The result must be wrapped in a `results' macro to be removed.
Leading white space is trimmed."
  (interactive)
  (let* ((el (or datum (org-element-context))))
    (when (org-element-type-p el '(inline-src-block inline-babel-call))
      (org-with-wide-buffer
       (goto-char (org-element-end el))
       (skip-chars-backward " \t")
       (let ((result (save-excursion
		       (skip-chars-forward
			" \t\n"
			(org-element-contents-end
			 (org-element-parent el)))
		       (org-element-context))))
	 (when (and (org-element-type-p result 'macro)
		    (string= (org-element-property :key result) "results"))
	   (delete-region		; And leading whitespace.
	    (point)
	    (progn (goto-char (org-element-end result))
		   (skip-chars-backward " \t\n")
		   (point)))))))))

;;; Query result

(defun org-babel-result-end ()
  "Return the point at the end of the current set of results."
  (cond ((looking-at-p "^[ \t]*$") (point)) ;no result
	((looking-at-p (format "^[ \t]*%s[ \t]*$" org-link-bracket-re))
	 (line-beginning-position 2))
	(t
	 (let ((element (org-element-at-point)))
	   (if (org-element-type-p
                element
		;; Possible results types.
                '(drawer example-block export-block fixed-width
                         special-block src-block item plain-list table
                         latex-environment))
	       (save-excursion
		 (goto-char (min (point-max) ;for narrowed buffers
				 (org-element-end element)))
		 (skip-chars-backward " \r\t\n")
		 (line-beginning-position 2))
	     (point))))))

(defun org-babel-where-is-src-block-result (&optional insert _info hash)
  "Find where the current source block results begin.

Return the point at the beginning of the result of the current
source block, specifically at the beginning of the results line.

If no result exists for this block return nil, unless optional
argument INSERT is non-nil.  In this case, create a results line
following the source block and return the position at its
beginning.  In the case of inline code, remove the results part
instead.

If optional argument HASH is a string, remove contents related to
RESULTS keyword if its hash is different.  Then update the latter
to HASH."
  (let ((context (org-element-context)))
    (catch :found
      (org-with-wide-buffer
       (pcase (org-element-type context)
	 ((or `inline-babel-call `inline-src-block)
	  ;; Results for inline objects are located right after them.
	  ;; There is no RESULTS line to insert either.
	  (let ((limit (or (org-element-contents-end (org-element-parent context))
                           (org-element-end (org-element-parent context)))))
	    (goto-char (org-element-end context))
	    (skip-chars-forward " \t\n" limit)
	    (throw :found
		   (and
		    (< (point) limit)
		    (let ((result (org-element-context)))
		      (and (org-element-type-p result 'macro)
			   (string= (org-element-property :key result)
				    "results")
			   (if (not insert) (point)
			     (delete-region
			      (point)
			      (progn
				(goto-char (org-element-end result))
				(skip-chars-backward " \t")
				(point)))
			     (point))))))))
	 ((or `babel-call `src-block)
	  (let* ((name (org-element-property :name context))
		 (named-results (and name (org-babel-find-named-result name))))
	    (goto-char (or named-results (org-element-end context)))
	    (cond
	     ;; Existing results named after the current source.
	     (named-results
	      (when (org-babel--clear-results-maybe hash)
		(org-babel--insert-results-keyword name hash))
	      (throw :found (point)))
	     ;; Named results expect but none to be found.
	     (name)
	     ;; No possible anonymous results at the very end of
	     ;; buffer or outside CONTEXT parent.
	     ((eq (point)
		  (or (pcase (org-element-type (org-element-parent context))
                        ((or `section `org-data)
                         (org-element-end (org-element-parent context)))
                        (_ (org-element-contents-end
                            (org-element-parent context))))
		      (point-max))))
	     ;; Check if next element is an anonymous result below
	     ;; the current block.
	     ((let* ((next (org-element-at-point))
		     (end (save-excursion
			    (goto-char
			     (org-element-post-affiliated next))
			    (line-end-position)))
		     (empty-result-re (concat org-babel-result-regexp "$"))
		     (case-fold-search t))
		(re-search-forward empty-result-re end t))
	      (forward-line 0)
	      (when (org-babel--clear-results-maybe hash)
		(org-babel--insert-results-keyword nil hash))
	      (throw :found (point))))))
	 ;; Ignore other elements.
	 (_ (throw :found nil))))
      ;; No result found.  Insert a RESULTS keyword below element, if
      ;; appropriate.  In this case, ensure there is an empty line
      ;; after the previous element.
      (when insert
	(save-excursion
	  (goto-char (min (org-element-end context) (point-max)))
	  (skip-chars-backward " \t\n")
	  (forward-line)
	  (unless (bolp) (insert "\n"))
	  (insert "\n")
	  (org-babel--insert-results-keyword
	   (org-element-property :name context) hash)
	  (point))))))

(defun org-babel-find-named-result (name)
  "Find a named result.
Return the location of the result named NAME in the current
buffer or nil if no such result exists."
  (save-excursion
    (goto-char (point-min))
    (let ((case-fold-search t)
	  (re (format "^[ \t]*#\\+%s.*?:[ \t]*%s[ \t]*$"
		      org-babel-results-keyword
		      (regexp-quote name))))
      (catch :found
	(while (re-search-forward re nil t)
	  (let ((element (org-element-at-point)))
	    (when (or (org-element-type-p element 'keyword)
		      (< (point)
			 (org-element-post-affiliated element)))
	      (throw :found (line-beginning-position)))))))))

;;; Result hash

(defun org-babel-current-result-hash (&optional _info)
  "Return the current in-buffer hash."
  (let ((result (org-babel-where-is-src-block-result nil)))
    (when result
      (org-with-point-at result
	(let ((case-fold-search t)) (looking-at org-babel-result-regexp))
	(match-string-no-properties 1)))))

(defun org-babel-hide-hash ()
  "Hide the hash in the current results line.
Only the initial `org-babel-hash-show' characters of the hash
will remain visible."
  (add-to-invisibility-spec '(org-babel-hide-hash . t))
  (save-excursion
    (when (and (let ((case-fold-search t))
		 (re-search-forward org-babel-result-regexp nil t))
               (match-string 1))
      (let* ((start (match-beginning 1))
             (hide-start (+ org-babel-hash-show start))
             (end (match-end 1))
             (hash (match-string 1))
             ov1 ov2)
        (setq ov1 (make-overlay start hide-start))
        (setq ov2 (make-overlay hide-start end))
        (overlay-put ov2 'invisible 'org-babel-hide-hash)
        (overlay-put ov1 'babel-hash hash)))))

;;;###autoload
(defun org-babel-hash-at-point (&optional point)
  "Return the value of the hash at POINT.
\\<org-mode-map>\
The hash is also added as the last element of the kill ring.
This can be called with `\\[org-ctrl-c-ctrl-c]'."
  (interactive)
  (let ((hash (car (delq nil (mapcar
			    (lambda (ol) (overlay-get ol 'babel-hash))
                            (overlays-at (or point (point))))))))
    (when hash (kill-new hash) (message hash))))

(defun org-babel-hide-all-hashes ()
  "Hide the hash in the current buffer.
Only the initial `org-babel-hash-show' characters of each hash
will remain visible.  This function should be called as part of
the `org-mode-hook'."
  (save-excursion
    (let ((case-fold-search t))
      (while (and (not org-babel-hash-show-time)
		  (re-search-forward org-babel-result-regexp nil t))
	(goto-char (match-beginning 0))
	(org-babel-hide-hash)
	(goto-char (match-end 0))))))
(add-hook 'org-mode-hook #'org-babel-hide-all-hashes)

(defun org-babel-result-hide-spec ()
  "Hide portions of results lines.
Add `org-babel-hide-result' as an invisibility spec for hiding
portions of results lines."
  (add-to-invisibility-spec '(org-babel-hide-result . t)))
(add-hook 'org-mode-hook #'org-babel-result-hide-spec)

(provide 'ob-core-result)

;;; ob-core-result.el ends here
